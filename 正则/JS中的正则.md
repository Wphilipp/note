#### 一、创建方法
```
var pattern1 = /s$/;  // RegExp直接量方式
var pattern2 = new RegExp('s$')  // RegExp构造函数方式
```
#### 二、字符直接量

> [...] 方括号内任意字符
> [^...] 不在方括号内的任意字符
> .  除了换行符和Unicode行终止符以外的任意字符
> \w  [a-zA-Z0-9_]
> \W  等价于 [^a-zA-Z0-9_]
> \s  任何Unicode空白符
> \S  任何unic非空白符
> \d [0-9]
> \D [^0-9]
> [\b]  退格直接量

#### 三、重复字符

> \* 重复0次到多次
> \+ 至少重复1次
> \?重复0次或1次
> \{n} 重复n次
> \{n, }至少重复n次
> \{n, m}重复n次到m次

注：JavaScript默认是贪婪匹配，如果需要懒惰匹配需要加？

#### 四、选择 分组 和引用字符

> |   选择，匹配的是该符号左边的子表达式或右边的子表达式
> (...)  组合，将几个项组合为一个单元，这个单元可通过“*”、“+”、“?”和"竖线"等符号修饰，而且可以记住和这个相匹配的字符串以供伺候的引用使用
> (?:...)  只组合，把项组合到一个单元，但不记忆与该组相匹配的字符
> \n  和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式（也有可能是嵌套），组索引是从左到右的左括号数，“(?:”形式的分组不编码

#### 五、 锚字符

> \^ | 匹配字符串的开头，在多行检索中，匹配一行的开头
> \$ | 匹配字符串的结尾，在多行检索中，匹配一行的结尾
> \\b | 匹配一个单词的边界，简而言之，就是位于字符\w和字符\W之间的位置，或位于字符\w和字符串的开头或结尾之间的位置（但需要注意的是在字符组内[\b]匹配的是退格符）
> \\B | 匹配非单词边界的位置
> \(?=p) | 零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符
> \(?!p) | 零宽负向先行断言，要求接下来的字符不与p匹配

#### 六、修饰符

> i   执行不区分大小写的匹配
> g  执行一个全局匹配，既找到所有的匹配，而不是在找到第一个之后就停止
> m  多行匹配模式，^匹配一行的开头和字符串的开头，$匹配一行的结尾和字符串的结束

#### 七、用于模式匹配的String方法
String.search(param)   参数是一个正则表达式，返回与参数匹配的子串的起始位置，如果找不到返回-1，如果参数是字符串，会先通过RegExp构造函数转换成正则表达式。

String.replace(a, b) 检索和替换， 第一个参数：正则表达式  第二个参数：要替换的字符串，也可以是函数，如果设置了g修饰符，则全部替换，否则，只替换第一个匹配成功的子串。

String.match()  参数：一个正则表达式。 返回：一个由结果匹配组成的数组。设置了g修饰符则返回所有数组，否则数组的第一个元素是匹配的字符串，剩下的是圆括号中的子表达式。

String.split() 参数：正则表达式或字符串。 返回子串组成的数组。

#### 八、RegExp对象
##### 1、RegExp构造函数
`var pattern = RegExp(a, b)
// a 正则表达式两条斜杠直接的文本
// b 可选 指定修饰符
`
##### 2、RegExp方法
exect(a)  参数是一个字符串 ，在该字符串中执行匹配检索，与String.match()非全局检索类似，返回数组或null
test(a)  参数是一个字符串。 返回布尔值
toString() 转出字符串形式。
